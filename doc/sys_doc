// 本文档零散的记录一些系统的逻辑设计，有待整理

关于关注任务：
	用户登录后，即使用api获取用户已关注用户的id列表，写入
	SESSION。在本次会话中即使用该SESSION，当用户成功关注或
	取消关注时，更新SESSION。
	在显示任务时，通过SESSION中的已关注列表，来判断显示。


关于注册
    普通注册过程，访问pre_reg.php，输入邮箱；
    pre_reg.php会向该邮箱发送一个注册链接，用户通过该链接
    到达reg.php完善注册信息，这样邮箱就被验证了。

    使用新浪微博注册，首次使用新浪微博登陆即相当于注册并绑定新浪微博。

    注意，如果一个用户先使用新浪微博注册了，然后又通过普通注册
    注册了一个微动力帐号，当ta用这个微动力帐号绑定自己的新浪微博帐号
    时，会自动转到用新浪微博注册的帐号。也就是说，微动力帐号无法绑定
    已经被绑定的新浪微博帐号，用户可以先用微博帐号登录，然后修改自己
    的信息。


关于检查用户做过的任务
about check_task
==========================================================
    目前测试版，让用户自己点击检测接口来检测。
    正式版应该是服务器在某个时刻运行脚本，完成检查，并且
    标记出检查结果。

正式版预期：

    检测转发任务：
        按do_task表中的记录检查：
        draft 1：
            用户在微动力上转发的微博产生的mid存入数据库。
            通过脚本判断此条微博是否存在来判断用户是否删除了该条微博。
            缺点：
                登录新浪微博才能访问具体微博的页面。
                抓取页面有一定困难。
            优点：
                不消耗api

        按用户检查：
        draft 2:
            从数据库中获取用户做过的转发任务产生的id/mid，
            然后使用api repost_by_me获取用户当前的真正转发列表，进行比对。
            缺点:
                repost_by_me只能由当前用户调用；
                repost_by_me只返回最新的转发微博，“最新”的定义尚不明确，since_id和max_id的用法亦不明确。
                repost_by_me方法没有base_app参数。
            优点：
                尚未发现
        draft 3:
            从数据库中获取用户做过的转发任务产生的id/mid，
            使用api user_timeline或user_timeline/ids获取用户通过本应用发布的微博。
            缺点:
                user_timeline中since_id和max_id的用法尚待测试；
                一次只能检测一个用户，
            优点：
                user_timeline可以通过指定base_app来指定只返回通过本应用发布的微博；
                不需要用户在线即可检测。

        按任务检查：
        draft 4:
            选取一个任务，将检验所有做过该任务的人的情况。
            从数据库do_task中获取做过该任务的用户做该任务时产生的id/mid和用户id，
            使用repost_timeline/ids获取该任务中原创微博的最新转发微博的mid，
            比对两者，不在后者中的前者被认为是删除了。
            缺点：
                repost_timeline/ids只能获取原创微博的转发id，
                这意味着我们需要保证我们提供的转发任务中的微博都是原创微博（这个按说并不难）。
                还有一个问题，如果这条原创微博在我们平台之外就被转发了很多次，也会给我们的检测
                带来困难，不过这种情况发生的概率很小。
            优点：
                base_app参数可以解决很多问题。
                一次检查一个任务。
                随时可以检查，无需用户在线。
                
    注意sae中的批量获取user_timeline的接口！ 这个批量接口在api文档中没有出现，它是否能节约api？？
    经测试，这是一个高级接口，需要申请才能使用。所以目前并不清楚它的效果。

    目前方案：
        draft 4;

    检测关注任务： 
        批量检查：（按任务检查）
        draft 1:
            获取任务用户的followers列表 http://open.weibo.com/wiki/2/friendships/followers
            然后比对数据库中存储的数据。
            note:
                一次检查一个任务（包括所有做了该任务的人）
        精确检查：（按用户检查）
        draft 2:
            根据用户uid和任务uid，判断两者关系。 http://open.weibo.com/wiki/2/friendships/show
            note:
                缺点：一次api调用只能检查一个用户
        互补检查：
        draft3:
            先对任务使用draft1获取五千个最新粉丝，检测出问题的用户再用draft2进行精确检查。

    目前方案：
        draft3;

    关于检测时机：
        检测的目的是看看用户有没有私自删粉删博，所以应该按照一定的周期检测，过了一定的时限之后，可以不再检测。
        使用cron

问题：
    1. 上线后每日需要检测的任务大概有多少？
    2. 多久检测一次？还是滚动检测？一个任务检查多少次？多久后不用再检测？
    3. 检测出的问题用户如何处理？已经给的钱怎么处理？（提现前，提现后）
    4. 失败的任务还给不给弥补的机会？

关于任务管理/录入模块：
    希望后期能够实现广告主客户自主通过平台发布任务。
    所以事先设立了广告主表，ader

    这样可以给广告主使用管理页面。
    管理页面需要广告主，手动编辑原创微博，或者从自己的微博帐号中指定一条原创微博。
    广告主用户只能发任务，不能做任务。

    统一两种发布任务的接口，可以默认一个，另一个需要手动选择，通过参数控制。


数据库设计升级@2012-09-21
    1. 将user表分离成多个表
        之前user表中含有大量的和平台如新浪微博相关的信息，如新浪uid，新浪微博等级等；
        分离后user表中仅含user本身的固有属性，和新浪微博有关的信息计入user_info_sina表，
        这样，当需要扩展到腾讯微博平台时，可以通过增加一个user_info_qq即可；
        而按照旧的设计，扩展时需要在user表中添加大量字段，不仅改动了表的本身，还将
        使表变得臃肿。
        同时分离出来的还有user_info_ali表，记录用户绑定的支付宝帐号信息。
    2. 同理，也应该将task表分离

